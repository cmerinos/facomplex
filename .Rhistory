devtools::document()
usethis::use_mit_license("Cesar Merino-Soto")
usethis::use_gpl3_license()
usethis::use_description()
usethis::use_readme_md()
devtools::document()
usethis::use_description()
usethis::use_readme_md()
devtools::document()
usethis::use_description()
usethis::use_description()
usethis::use_description()
usethis::use_readme_md()
devtools::document()
LSI(ex1_data)
#'
#' # Compute the Loading Simplicity Index
#' LSI(ex1_data)
#'
#' # View item-level and global results
#' LSI(ex1_data)$LSI.item)
#' LSI(ex1_data)$LSI.global
#'
#' @author Cesar Merino-Sotro
#' @export
LSI <- function(loadings) {
# Validar que las cargas factoriales sean una matriz o data.frame
if (!is.matrix(loadings) && !is.data.frame(loadings)) {
stop("El argumento 'loadings' debe ser una matriz o un data.frame.")
}
# Convertir a matriz si es necesario
B <- as.matrix(loadings)
# Dimensiones
p <- nrow(B) # Número de variables
r <- ncol(B) # Número de factores
# Constante epsilon
epsilon <- 1e-6
# Calcular w por ítem
w_items <- apply(B, 1, function(row) {
sum((row^2 + epsilon) * 10^(row^2)) / r
})
# Promedio de w para todos los ítems (índice global w)
w_global <- mean(w_items)
# Calcular e (mínimo posible de w)
e <- (1 / r) * sum((1 / (1 + epsilon)) * 10^epsilon)
# Calcular LS (Loading Simplicity Index) global
LS_global <- (w_global - e) / (1 - e)
# Calcular LS para cada ítem
LS_items <- (w_items - e) / (1 - e)
# Retornar resultados como lista
return(list(
LSI.item = LS_items,   # Índice por ítem
LSI.global = LS_global     # Índice global
))
}
LSI(ex1_data)
FSI(data = ex1_data,
items_target = list(F1 = c(1, 2, 3, 4, 5, 6),
F2 = c(7, 8, 9),
F3 = c(10, 11, 12)))
#'                                                   rstarts = 30,
#'                                                   algorithm = "gpa",
#'                                                   std.ov = TRUE))
#'
#' FSI(data = lavInspect(INV.esem.fit, what = "std")$lambda,
#'     items_target = list(f1 = c(1, 2, 3, 4, 5, 6),
#'                         f2 = c(7, 8, 9, 10, 11, 12)))
#'
#' @author Tu Nombre
#' @export
FSI <- function(data, items_target) {
# Convert matrices to data frame
if (is.matrix(data)) {
data <- as.data.frame(data)
}
# Verify that data is a data frame
if (!is.data.frame(data)) {
stop("The argument 'data' must be a data frame or a matrix")
}
# Get row names if available
row_names <- rownames(data)
if (is.null(row_names) || all(row_names == "")) {
row_names <- paste0("FSI_", seq_len(nrow(data)))
}
# Square all factor loadings
data_squared <- data^2
# Initialize lists to store results
FSI_F <- list()
FSI_i <- list()
# Initialize variables for total calculation
SSTF_total <- 0
SS_NTF_total <- 0
# Compute FSI_F for each factor
for (factor in names(items_target)) {
# Get the index of target items for the current factor
target_rows <- items_target[[factor]]
# Compute the sum of squared target items (SSTF)
SSTF <- sum(data_squared[target_rows, factor])
# Compute the sum of squared non-target items (SS-NTF)
all_rows <- 1:nrow(data_squared)
no_target_rows <- setdiff(all_rows, target_rows)
SS_NTF <- sum(data_squared[no_target_rows, factor])
# Compute RATIO
RATIO <- SS_NTF / SSTF
# Compute FSI_F
FSI_F[[factor]] <- 1 - RATIO
# Accumulate for total calculation
SSTF_total <- SSTF_total + SSTF
SS_NTF_total <- SS_NTF_total + SS_NTF
# Compute FSI_i for each target item in the current factor
for (item in target_rows) {
target_loading <- data_squared[item, factor]
sum_non_target <- sum(data_squared[item, setdiff(names(data), factor)])
# Compute FSI_i for the current item
FSI_i[[row_names[item]]] <- 1 - (sum_non_target / target_loading)
}
}
# Compute FSI_total
RATIO_total <- SS_NTF_total / SSTF_total
FSI_total <- 1 - RATIO_total
# Create lists for results
result_list <- list(
FSI_total = FSI_total,
FSI_F = FSI_F,
FSI_i = data.frame(
Items = names(FSI_i),
FSI_i = round(unlist(FSI_i), 3),
row.names = NULL  # Remove automatic row names
)
)
# Format and round results
result_list$FSI_total <- round(result_list$FSI_total, 3)
result_list$FSI_F <- sapply(result_list$FSI_F, round, 3)
return(result_list)
}
ex1_data <- data.frame(
F1 = c(0.536, 0.708, 0.600, 0.673, 0.767, 0.481, -0.177, 0.209, -0.097, -0.115, 0.047, 0.024),
F2 = c(-0.110, 0.026, 0.076, 0.011, -0.160, 0.106, 0.668, 0.438, 0.809, 0.167, 0.128, 0.041),
F3 = c(-0.100, 0.036, 0.086, 0.021, -0.150, 0.116, 0.678, 0.448, 0.819, 0.577, 0.738, 0.751))
LSI(ex1_data)
#'
#' # Compute the Loading Simplicity Index
#' LSI(ex1_data)
#'
#' # View item-level and global results
#' LSI(ex1_data)$LSI.item)
#' LSI(ex1_data)$LSI.global
#'
#' @author Cesar Merino-Sotro
#' @export
LSI <- function(loadings) {
# Validar entrada
if (!is.matrix(loadings) && !is.data.frame(loadings)) {
stop("The argument 'loadings' must be a matrix or data frame.")
}
B <- as.matrix(loadings)
p <- nrow(B)
r <- ncol(B)
epsilon <- 1e-6
# Calcular w_i para cada ítem (no es LSI aún)
w_items <- apply(B, 1, function(row) {
sum((row^2 + epsilon) * 10^(row^2)) / r
})
# Calcular w global
w_global <- mean(w_items)
# Calcular e (mínimo posible de w)
e <- (1 / r) * sum((1 / (1 + epsilon)) * 10^epsilon)
# Calcular LSI global con normalización
LSI_global <- (w_global - e) / (1 - e)
# Retornar valores
return(list(
w_per_item = round(w_items, 4),  # valores originales w_i (sin escalar)
LSI_global = round(LSI_global, 4)
))
}
LSI(ex1_data)
FSI(data = ex1_data,
items_target = list(F1 = c(1, 2, 3, 4, 5, 6),
F2 = c(7, 8, 9),
F3 = c(10, 11, 12)))
#' @title BSI - Bentler Simplicity Index
#' @description Computes the Bentler Simplicity Index (BSI) from a matrix or
#' data frame of factor loadings.
#'
#' @param data A matrix or data frame of factor loadings, with k rows (items) and n columns (factors).
#' @param item_names Optional vector of item names. If NULL, default names will
#' be generated.
#' @param sort_items Controls the ordering of items in the output. Options are
#' `"up"` (ascending), `"down"` (descending), or `NULL` (no ordering). Default
#' is `NULL`.
#'
#' @return A list with two components:
#' \itemize{
#'   \item `BSI_per_item`: A data frame with the BSI calculated for each item.
#'   \item `BSI_global`: The overall Bentler Simplicity Index (mean across all items).
#' }
#'
#' @details
#' The Bentler Simplicity Index (BSI) measures the extent to which each item loads primarily on one factor,
#' indicating a simpler factor structure. Values closer to 1 suggest higher simplicity, while values near 0
#' indicate factorial complexity.
#'
#' Users can choose whether to sort items by their simplicity values or retain the original item order.
#'
#' @references
#' Bentler, P. M. (1977). Factor simplicity index and transformations. *Psychometrika, 42*(2), 277–295.
#' https://doi.org/10.1007/BF02294054
#'
#' @seealso \code{\link{plot_simplicity}} for graphical representation of BSI values.
#'
#' @examples
#' # Example data
#' ex1_data <- data.frame(
#'   F1 = c(0.536, 0.708, 0.600, 0.673, 0.767, 0.481, -0.177, 0.209, -0.097, -0.115, 0.047, 0.024),
#'   F2 = c(-0.110, 0.026, 0.076, 0.011, -0.160, 0.106, 0.668, 0.438, 0.809, 0.167, 0.128, 0.041),
#'   F3 = c(-0.100, 0.036, 0.086, 0.021, -0.150, 0.116, 0.678, 0.448, 0.819, 0.577, 0.738, 0.751)
#' )
#'
#' # Compute BSI without ordering
#' BSI_result <- BSI(ex1_data)
#'
#' # Compute BSI with ascending order
#' BSI_result_up <- BSI(ex1_data, sort_items = "up")
#'
#' # Compute BSI with descending order
#' BSI_result_down <- BSI(ex1_data, sort_items = "down")
#'
#' @author Your Name
#' @export
BSI <- function(data, item_names = NULL, sort_items = NULL) {
# Validar si el argumento es una matriz o data.frame
if (!is.matrix(data) && !is.data.frame(data)) {
stop("El argumento 'data' debe ser una matriz o un data.frame.")
}
# Convertir data.frame a matriz si es necesario
loadings <- as.matrix(data)
# Asegurarse de que los valores sean numéricos
if (!is.numeric(loadings)) {
stop("Los valores de 'data' deben ser numéricos (cargas factoriales).")
}
# Manejar posibles NA en la matriz
if (any(is.na(loadings))) {
warning("Se encontraron valores NA. Se ignorarán en los cálculos.")
loadings[is.na(loadings)] <- 0  # Opcional: reemplazar NA con 0
}
# Calcular BSI por ítem (fila)
bsi_values <- rowSums(loadings^4) / (rowSums(loadings^2)^2)
# Calcular el índice de simplicidad global como promedio de los valores por ítem
simplicity_index <- mean(bsi_values, na.rm = TRUE)
# Si el usuario no proporciona nombres de ítems, generar nombres automáticos
if (is.null(item_names)) {
item_names <- paste0("Item_", seq_along(bsi_values))
}
# Crear un data frame con los valores de BSI
results <- data.frame(
Item = item_names,
BSI_Value = round(bsi_values, 3),
stringsAsFactors = FALSE
)
# Aplicar ordenamiento si el usuario lo indica
if (!is.null(sort_items)) {
if (sort_items == "up") {
results <- results[order(results$BSI_Value), ]
} else if (sort_items == "down") {
results <- results[order(results$BSI_Value, decreasing = TRUE), ]
} else {
stop("El argumento 'sort_items' debe ser 'up', 'down' o NULL.")
}
}
# Retornar los resultados
return(list(
BSI_per_item = results,
BSI_global = round(simplicity_index, 3)
))
}
BSI(data = ex1_data, item_names = list(F1 = c(1, 2, 3, 4, 5, 6),
F2 = c(7, 8, 9),
F3 = c(10, 11, 12)))
BSI(data = ex1_data)
seq(1:12)
BSI(data = ex1_data, item_names = seq(1:12))
BSI(data = ex1_data, sort_items = "up")
BSI(data = ex1_data, item_names = seq(1:12), sort_items = "up")
BSI(data = ex1_data, item_names = seq(1:12), sort_items = "down")
#' BSI_result <- BSI(ex1_data)
#'
#' # Sort by ascending order
#' BSI_result_up <- BSI(ex1_data, sort_items = "up")
#'
#' # Sort by descending order
#' BSI_result_down <- BSI(ex1_data, sort_items = "down")
#'
#' @author Cesar Merino-Soto
#' @export
BSI <- function(data, item_names = NULL, sort_items = NULL) {
# Validar si el argumento es una matriz o data.frame
if (!is.matrix(data) && !is.data.frame(data)) {
stop("El argumento 'data' debe ser una matriz o un data.frame.")
}
# Convertir data.frame a matriz si es necesario
loadings <- as.matrix(data)
# Asegurarse de que los valores sean numéricos
if (!is.numeric(loadings)) {
stop("Los valores de 'data' deben ser numéricos (cargas factoriales).")
}
# Manejar posibles NA en la matriz
if (any(is.na(loadings))) {
warning("Se encontraron valores NA. Se ignorarán en los cálculos.")
loadings[is.na(loadings)] <- 0  # Opcional: reemplazar NA con 0
}
# Calcular BSI por ítem (fila)
bsi_values <- rowSums(loadings^4) / (rowSums(loadings^2)^2)
# Calcular el índice de simplicidad global como promedio de los valores por ítem
simplicity_index <- mean(bsi_values, na.rm = TRUE)
# Si el usuario no proporciona nombres de ítems, generar nombres automáticos
if (is.null(item_names)) {
item_names <- paste0("Item_", seq_along(bsi_values))
}
# Crear un data frame con los valores de BSI
results <- data.frame(
Item = item_names,
BSI_Value = round(bsi_values, 3),
stringsAsFactors = FALSE
)
# Aplicar ordenamiento si el usuario lo indica
if (!is.null(sort_items)) {
if (sort_items == "up") {
results <- results[order(results$BSI_Value), ]
} else if (sort_items == "down") {
results <- results[order(results$BSI_Value, decreasing = TRUE), ]
} else {
stop("El argumento 'sort_items' debe ser 'up', 'down' o NULL.")
}
}
# Retornar los resultados
return(list(
BSI.item = results,
BSI.global = round(simplicity_index, 3)
))
}
BSI(data = ex1_data, sort_items = "up")
#' BSI_result <- BSI(ex1_data)
#'
#' # Sort by ascending order
#' BSI_result_up <- BSI(ex1_data, sort_items = "up")
#'
#' # Sort by descending order
#' BSI_result_down <- BSI(ex1_data, sort_items = "down")
#'
#' @author Cesar Merino-Soto
#' @export
BSI <- function(data, item_names = NULL, sort_items = NULL) {
# Validar si el argumento es una matriz o data.frame
if (!is.matrix(data) && !is.data.frame(data)) {
stop("El argumento 'data' debe ser una matriz o un data.frame.")
}
# Convertir data.frame a matriz si es necesario
loadings <- as.matrix(data)
# Asegurarse de que los valores sean numéricos
if (!is.numeric(loadings)) {
stop("Los valores de 'data' deben ser numéricos (cargas factoriales).")
}
# Manejar posibles NA en la matriz
if (any(is.na(loadings))) {
warning("Se encontraron valores NA. Se ignorarán en los cálculos.")
loadings[is.na(loadings)] <- 0  # Opcional: reemplazar NA con 0
}
# Calcular BSI por ítem (fila)
bsi_values <- rowSums(loadings^4) / (rowSums(loadings^2)^2)
# Calcular el índice de simplicidad global como promedio de los valores por ítem
simplicity_index <- mean(bsi_values, na.rm = TRUE)
# Si el usuario no proporciona nombres de ítems, generar nombres automáticos
if (is.null(item_names)) {
item_names <- paste0("Item_", seq_along(bsi_values))
}
# Crear un data frame con los valores de BSI
results <- data.frame(
Item = item_names,
BSI.Value = round(bsi_values, 3),
stringsAsFactors = FALSE
)
# Aplicar ordenamiento si el usuario lo indica
if (!is.null(sort_items)) {
if (sort_items == "up") {
results <- results[order(results$BSI_Value), ]
} else if (sort_items == "down") {
results <- results[order(results$BSI_Value, decreasing = TRUE), ]
} else {
stop("El argumento 'sort_items' debe ser 'up', 'down' o NULL.")
}
}
# Retornar los resultados
return(list(
BSI.item = results,
BSI.global = round(simplicity_index, 3)
))
}
BSI(data = ex1_data, sort_items = "up")
#' BSI_result <- BSI(ex1_data)
#'
#' # Sort by ascending order
#' BSI_result_up <- BSI(ex1_data, sort_items = "up")
#'
#' # Sort by descending order
#' BSI_result_down <- BSI(ex1_data, sort_items = "down")
#'
#' @author Cesar Merino-Soto
#' @export
BSI <- function(data, item_names = NULL, sort_items = NULL) {
# Validar si el argumento es una matriz o data.frame
if (!is.matrix(data) && !is.data.frame(data)) {
stop("El argumento 'data' debe ser una matriz o un data.frame.")
}
# Convertir data.frame a matriz si es necesario
loadings <- as.matrix(data)
# Asegurarse de que los valores sean numéricos
if (!is.numeric(loadings)) {
stop("Los valores de 'data' deben ser numéricos (cargas factoriales).")
}
# Manejar posibles NA en la matriz
if (any(is.na(loadings))) {
warning("Se encontraron valores NA. Se ignorarán en los cálculos.")
loadings[is.na(loadings)] <- 0  # Opcional: reemplazar NA con 0
}
# Calcular BSI por ítem (fila)
bsi_values <- rowSums(loadings^4) / (rowSums(loadings^2)^2)
# Calcular el índice de simplicidad global como promedio de los valores por ítem
simplicity_index <- mean(bsi_values, na.rm = TRUE)
# Si el usuario no proporciona nombres de ítems, generar nombres automáticos
if (is.null(item_names)) {
item_names <- paste0("Item_", seq_along(bsi_values))
}
# Crear un data frame con los valores de BSI
results <- data.frame(
Item = item_names,
BSI.Value = round(bsi_values, 3),
stringsAsFactors = FALSE
)
# Aplicar ordenamiento si el usuario lo indica
if (!is.null(sort_items)) {
if (sort_items == "up") {
results <- results[order(results$BSI.Value), ]
} else if (sort_items == "down") {
results <- results[order(results$BSI.Value, decreasing = TRUE), ]
} else {
stop("El argumento 'sort_items' debe ser 'up', 'down' o NULL.")
}
}
# Retornar los resultados
return(list(
BSI.item = results,
BSI.global = round(simplicity_index, 3)
))
}
BSI(data = ex1_data, sort_items = "up")
#' BSI_result <- BSI(ex1_data)
#'
#' # Sort by ascending order
#' BSI_result_up <- BSI(ex1_data, sort_items = "up")
#'
#' # Sort by descending order
#' BSI_result_down <- BSI(ex1_data, sort_items = "down")
#'
#' @author Cesar Merino-Soto
#' @export
BSI <- function(data, item_names = NULL, sort_items = NULL) {
# Validar si el argumento es una matriz o data.frame
if (!is.matrix(data) && !is.data.frame(data)) {
stop("El argumento 'data' debe ser una matriz o un data.frame.")
}
# Convertir data.frame a matriz si es necesario
loadings <- as.matrix(data)
# Asegurarse de que los valores sean numéricos
if (!is.numeric(loadings)) {
stop("Los valores de 'data' deben ser numéricos (cargas factoriales).")
}
# Manejar posibles NA en la matriz
if (any(is.na(loadings))) {
warning("Se encontraron valores NA. Se ignorarán en los cálculos.")
loadings[is.na(loadings)] <- 0  # Opcional: reemplazar NA con 0
}
# Calcular BSI por ítem (fila)
bsi_values <- rowSums(loadings^4) / (rowSums(loadings^2)^2)
# Calcular el índice de simplicidad global como promedio de los valores por ítem
simplicity_index <- mean(bsi_values, na.rm = TRUE)
# Si el usuario no proporciona nombres de ítems, generar nombres automáticos
if (is.null(item_names)) {
item_names <- paste0("Item.", seq_along(bsi_values))
}
# Crear un data frame con los valores de BSI
results <- data.frame(
Item = item_names,
BSI.Value = round(bsi_values, 3),
stringsAsFactors = FALSE
)
# Aplicar ordenamiento si el usuario lo indica
if (!is.null(sort_items)) {
if (sort_items == "up") {
results <- results[order(results$BSI.Value), ]
} else if (sort_items == "down") {
results <- results[order(results$BSI.Value, decreasing = TRUE), ]
} else {
stop("El argumento 'sort_items' debe ser 'up', 'down' o NULL.")
}
}
# Retornar los resultados
return(list(
BSI.item = results,
BSI.global = round(simplicity_index, 3)
))
}
BSI(data = ex1_data, sort_items = "up")
